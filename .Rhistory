HEI2015_MAX_TOTALPRO_SERV = 2.5
HEI2015_MIN_SEAPLANTPRO_SERV = 0
HEI2015_MAX_SEAPLANTPRO_SERV = 0.8
HEI2015_MIN_WHOLEGRAIN_SERV = 0
HEI2015_MAX_WHOLEGRAIN_SERV = 1.5
HEI2015_MIN_DAIRY_SERV = 0
HEI2015_MAX_DAIRY_SERV = 1.3
HEI2015_MIN_FATTYACID_SERV = 1.2
HEI2015_MAX_FATTYACID_SERV = 2.5
HEI2015_MIN_REFINEDGRAIN_SERV = 4.3
HEI2015_MAX_REFINEDGRAIN_SERV = 1.8
HEI2015_MIN_SODIUM_SERV = 2.0
HEI2015_MAX_SODIUM_SERV = 1.1
HEI2015_MIN_ADDEDSUGAR_SERV = 26
HEI2015_MAX_ADDEDSUGAR_SERV = 6.5
HEI2015_MIN_SATFAT_SERV = 16
HEI2015_MAX_SATFAT_SERV = 8
HEI2015_HEALTHY1 = function(actual, min, max){
case_when(
actual >= max ~ HEI2015_MAX1,
actual <= min ~ HEI2015_MIN,
TRUE ~ HEI2015_MIN+(actual-min)*HEI2015_MAX1/(max-min)
)
}
HEI2015_HEALTHY2 = function(actual, min, max){
case_when(
actual >= max ~ HEI2015_MAX2,
actual <= min ~ HEI2015_MIN,
TRUE ~ HEI2015_MIN+(actual-min)*HEI2015_MAX2/(max-min)
)
}
HEI2015_UNHEALTHY = function(actual, min, max){
case_when(
actual >= min ~ HEI2015_MIN,
actual <= max ~ HEI2015_MAX2,
TRUE ~ HEI2015_MIN+(actual-min)*HEI2015_MAX2/(max-min)
)
}
SERV_DATA=SERV_DATA %>%
mutate(
HEI2015_TOTALFRT = HEI2015_HEALTHY1(TOTALFRT_SERV, HEI2015_MIN_TOTALFRT_SERV, HEI2015_MAX_TOTALFRT_SERV),
HEI2015_FRT = HEI2015_HEALTHY1(FRT_SERV, HEI2015_MIN_FRT_SERV, HEI2015_MAX_FRT_SERV),
HEI2015_VEG = HEI2015_HEALTHY1(VEG_SERV, HEI2015_MIN_VEG_SERV, HEI2015_MAX_VEG_SERV),
HEI2015_GREENNBEAN = HEI2015_HEALTHY1(GREENNBEAN_SERV, HEI2015_MIN_GREENNBEAN_SERV, HEI2015_MAX_GREENNBEAN_SERV),
HEI2015_TOTALPRO = HEI2015_HEALTHY1(TOTALPRO_SERV, HEI2015_MIN_TOTALPRO_SERV, HEI2015_MAX_TOTALPRO_SERV),
HEI2015_SEAPLANTPRO = HEI2015_HEALTHY1(SEAPLANTPRO_SERV, HEI2015_MIN_SEAPLANTPRO_SERV, HEI2015_MAX_SEAPLANTPRO_SERV),
HEI2015_WHOLEGRAIN = HEI2015_HEALTHY2(WHOLEGRAIN_SERV, HEI2015_MIN_WHOLEGRAIN_SERV, HEI2015_MAX_WHOLEGRAIN_SERV),
HEI2015_DAIRY = HEI2015_HEALTHY2(DAIRY_SERV, HEI2015_MIN_DAIRY_SERV, HEI2015_MAX_DAIRY_SERV),
HEI2015_FATTYACID = HEI2015_HEALTHY2(FATTYACID_SERV, HEI2015_MIN_FATTYACID_SERV, HEI2015_MAX_FATTYACID_SERV),
HEI2015_REFINEDGRAIN = HEI2015_UNHEALTHY(REFINEDGRAIN_SERV, HEI2015_MIN_REFINEDGRAIN_SERV, HEI2015_MAX_REFINEDGRAIN_SERV),
HEI2015_SODIUM = HEI2015_UNHEALTHY(SODIUM_SERV, HEI2015_MIN_SODIUM_SERV, HEI2015_MAX_SODIUM_SERV),
HEI2015_ADDEDSUGAR = HEI2015_UNHEALTHY(ADDEDSUGAR_SERV, HEI2015_MIN_ADDEDSUGAR_SERV, HEI2015_MAX_ADDEDSUGAR_SERV),
HEI2015_SATFAT = HEI2015_UNHEALTHY(SATFAT_SERV, HEI2015_MIN_SATFAT_SERV, HEI2015_MAX_SATFAT_SERV),
HEI2015_ALL= HEI2015_TOTALFRT + HEI2015_FRT + HEI2015_VEG + HEI2015_GREENNBEAN +
HEI2015_TOTALPRO + HEI2015_SEAPLANTPRO + HEI2015_WHOLEGRAIN + HEI2015_DAIRY +
HEI2015_FATTYACID + HEI2015_REFINEDGRAIN + HEI2015_SODIUM + HEI2015_ADDEDSUGAR +
HEI2015_SATFAT
)
for(i in 1:length(SERV_DATA$TOTALKCAL)){
if (SERV_DATA$TOTALKCAL[i] == 0){
SERV_DATA$HEI2015_TOTALFRT[i] = 0
SERV_DATA$HEI2015_FRT[i] = 0
SERV_DATA$HEI2015_VEG[i] = 0
SERV_DATA$HEI2015_GREENNBEAN[i] = 0
SERV_DATA$HEI2015_TOTALPRO[i] = 0
SERV_DATA$HEI2015_SEAPLANTPRO[i] = 0
SERV_DATA$HEI2015_WHOLEGRAIN[i] = 0
SERV_DATA$HEI2015_DAIRY[i] = 0
SERV_DATA$HEI2015_FATTYACID[i] = 0
SERV_DATA$HEI2015_REFINEDGRAIN[i] = 0
SERV_DATA$HEI2015_ADDEDSUGAR[i] = 0
SERV_DATA$HEI2015_ALL[i] = 0
}
}
SERV_DATA %>%
select(HEI2015_ALL, HEI2015_TOTALFRT, HEI2015_FRT, HEI2015_VEG, HEI2015_GREENNBEAN,
HEI2015_TOTALPRO, HEI2015_SEAPLANTPRO, HEI2015_WHOLEGRAIN, HEI2015_DAIRY,
HEI2015_FATTYACID, HEI2015_REFINEDGRAIN, HEI2015_SODIUM, HEI2015_ADDEDSUGAR,
HEI2015_SATFAT)
}
#' AHEI_SERV Calculation
#'
#' Calculate the serving sizes needed for calculating the AHEI dietary index per 1 day
#' @param RAW_DATA The raw data file that includes results and raw data of the dietary assessment
#' @param TYPE The type of dietary assessment you use. Current supported dietary assessment(s): BLOCK.
#' @return The serving sizes for the AHEI index/score
#' @examples
#' AHEI_SERV(RAW_DATA, TYPE="BLOCK")
#' @export
AHEI_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Standard food frequency and portion size response code
STD_FOOD_FREQ = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
STD_FREQ_SERV = c(0, 1/90, 1/30, 2.5/30, 1/7, 2/7, 3.5/7, 5.5/7, 1)
STD_FOOD_PORT = c(1, 2, 3, 4)
STD_PORT_SERV = c(0.25, 0.5, 1, 2)
STD_LUNCHMEAT_PORT_SERV = c(1, 2, 3, 4)
STD_HOTDOG_PORT_SERV = c(1, 2, 3)
STD_FOOD_FREQ_DF = data.frame(STD_FOOD_FREQ, STD_FREQ_SERV)
STD_FOOD_PORT_DF= data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Functions to match actual food frequency and portion to the standards
foodfreq = function(actual, ref=STD_FOOD_FREQ_DF){
ref[match(actual, ref[,1]),2]
}
foodport = function(actual, ref=STD_FOOD_PORT_DF){
ref[match(actual, ref[,1]),2]
}
#Serving calculation for AHEI 2010
RAW_DATA %>%
mutate(
VEG_SERV = V_DPYEL + 0.5*V_DRKGR + V_OTHER + V_STARCY + V_TOMATO,
F_BERRIES = foodfreq(STRAWBERRIESFREQ)*foodport(STRAWBERRIESQUAN),
F_WHOLE = F_SOLID - F_BERRIES + F_BERRIES*2,
FRT_SERV = F_WHOLE,
WGRAIN_SERV = G_WHL/0.035274,
NUTSLEG_SERV = (LEGUMES*4) + M_NUTSD + M_SOY,
N3FAT_SERV = (DT_FA205 + DT_FA226)*1000,
PUFA_SERV = (((DT_TOTN6 + DT_TOTN3 - DT_FA205 - DT_FA226)*9)/ DT_KCAL)*100,
SSB_FRTJ_SERV = (GROUP_SUGARYBEVG_TOTAL_GRAMS / 240) + F_JUICE,
REDPROC_MEAT_SERV = (M_FRANK /1.5) + (M_MEAT/4),
TRANS_SERV = ((DT_TRFAT * 9) / DT_KCAL)*100,
ALCOHOL_SERV=A_BEV,
SODIUM_SERV = DT_SODI
)
} else{
print("Sorry, your input type is not currently supported. Current supported types include: BLOCK")
}
}
#' DASH_SERV Calculation
#'
#' Calculate the serving sizes needed for calculating the DASH dietary index per 1 day
#' @param RAW_DATA The raw data file that includes results and raw data of the dietary assessment
#' @param TYPE The type of dietary assessment you use. Current supported dietary assessment(s): BLOCK.
#' @return The serving sizes for the DASH index/score
#' @examples
#' DASH_SERV(RAW_DATA, TYPE="BLOCK")
#' @export
DASH_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Standard food frequency and portion size response code
STD_FOOD_FREQ = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
STD_FREQ_SERV = c(0, 1/90, 1/30, 2.5/30, 1/7, 2/7, 3.5/7, 5.5/7, 1)
STD_FOOD_PORT = c(1, 2, 3, 4)
STD_PORT_SERV = c(0.25, 0.5, 1, 2)
STD_LUNCHMEAT_PORT_SERV = c(1, 2, 3, 4)
STD_HOTDOG_PORT_SERV = c(1, 2, 3)
STD_FOOD_FREQ_DF = data.frame(STD_FOOD_FREQ, STD_FREQ_SERV)
STD_FOOD_PORT_DF = data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Match participant response food frequency to the standard food frequency response code
YOGURT_FOOD_PORT = c(2, 3)
YOGURT_PORT_SERV = c(0.5, 1)
YOGURT_PORT_DF = data.frame(STD_FOOD_PORT, STD_PORT_SERV)
BUTTERMILK_FOOD_PORT = c(1, 2, 3, 4)
BUTTERMILK_PORT_SERV = c(0.25, 0.5, 1, 2)
BUTTERMILK_PORT_DF = data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Functions to match actual food frequency and portion to the standards
foodfreq = function(actual, ref=STD_FOOD_FREQ_DF){
ref[match(actual, ref[,1]),2]
}
foodport = function(actual, ref=STD_FOOD_PORT_DF){
ref[match(actual, ref[,1]),2]
}
RAW_DATA %>%
mutate(
F_BERRIES = foodfreq(STRAWBERRIESFREQ)*foodport(STRAWBERRIESQUAN),
F_WHOLE = F_SOLID - F_BERRIES + F_BERRIES*2,
FRT_FRTJ_SERV = F_WHOLE + JUICE100,
VEG_SERV = V_DPYEL + 0.5*V_DRKGR + V_OTHER + V_STARCY + V_TOMATO,
NUTSLEG_SERV = (LEGUMES*4) + M_NUTSD + M_SOY,
WGRAIN_SERV = G_WHL,
LOWF_MILK_SERV = ifelse(MILKTYPE==2 | MILKTYPE==3 | MILKTYPE==4,
foodfreq(MILKFREQ) * MILKQUAN,
0),
YOGURT_SERV = (foodfreq(YOGURTONLYFREQ) *
foodport(YOGURTONLYQUAN, ref=YOGURT_PORT_DF)) +
(foodfreq(BUTTERMILKFREQ) *
foodport(BUTTERMILKQUAN, ref=BUTTERMILK_PORT_DF)),
LOWF_ICECREAMFROYO_SERV = ifelse(ICECREAMFROYOTYPE == 2,
foodfreq(ICECREAMFROYOFREQ) *
foodport(ICECREAMFROYOQUAN)*2,
0),
LOWF_CHEESE_SERV = ifelse(CHEESETYPE == 1,
foodfreq(CHEESEFREQ) * CHEESEQUAN,
0),
LOWF_DAIRY_SERV = LOWF_MILK_SERV+YOGURT_SERV+LOWF_ICECREAMFROYO_SERV+LOWF_CHEESE_SERV,
SODIUM_SERV = DT_SODI,
REDPROC_MEAT_SERV = (M_FRANK /1.5) + (M_MEAT/4),
SSB_FRTJ_SERV = (GROUP_SUGARYBEVG_TOTAL_GRAMS / 240) + F_JUICE - JUICE100
)
} else{
print("Sorry, your input type is not currently supported. Current supported types include: BLOCK")
}
}
#' DASHI_SERV Calculation
#'
#' Calculate the serving sizes needed for calculating the DASHI dietary index per 1 day
#' @param RAW_DATA The raw data file that includes results and raw data of the dietary assessment
#' @param TYPE The type of dietary assessment you use. Current supported dietary assessment(s): BLOCK.
#' @return The serving sizes for the DASHI index/score
#' @examples
#' DASHI_SERV(RAW_DATA, TYPE="BLOCK")
#' @export
DASHI_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Standard food frequency and portion size response code
STD_FOOD_FREQ = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
STD_FREQ_SERV = c(0, 1/90, 1/30, 2.5/30, 1/7, 2/7, 3.5/7, 5.5/7, 1)
STD_FOOD_PORT = c(1, 2, 3, 4)
STD_PORT_SERV = c(0.25, 0.5, 1, 2)
STD_LUNCHMEAT_PORT_SERV = c(1, 2, 3, 4)
STD_HOTDOG_PORT_SERV = c(1, 2, 3)
STD_FOOD_FREQ_DF = data.frame(STD_FOOD_FREQ, STD_FREQ_SERV)
STD_FOOD_PORT_DF= data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Match participant response food frequency to the standard food frequency response code
YOGURT_FOOD_PORT = c(2, 3)
YOGURT_PORT_SERV = c(0.5, 1)
YOGURT_PORT_DF = data.frame(STD_FOOD_PORT, STD_PORT_SERV)
BUTTERMILK_FOOD_PORT = c(1, 2, 3, 4)
BUTTERMILK_PORT_SERV = c(0.25, 0.5, 1, 2)
BUTTERMILK_PORT_DF = data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Functions to match actual food frequency and portion to the standards
foodfreq = function(actual, ref=STD_FOOD_FREQ_DF){
ref[match(actual, ref[,1]),2]
}
foodport = function(actual, ref=STD_FOOD_PORT_DF){
ref[match(actual, ref[,1]),2]
}
RAW_DATA %>%
mutate(
F_BERRIES = foodfreq(STRAWBERRIESFREQ)*foodport(STRAWBERRIESQUAN),
F_WHOLE = F_SOLID - F_BERRIES + F_BERRIES*2,
VEG_SERV = V_DPYEL + 0.5*V_DRKGR + V_OTHER + V_STARCY + V_TOMATO,
FRT_SERV = F_WHOLE + JUICE100,
NUTSLEG_SERV = (LEGUMES*4) + M_NUTSD + M_SOY,
LOWF_MILK_SERV = ifelse(MILKTYPE==2 | MILKTYPE==3 | MILKTYPE==4,
foodfreq(MILKFREQ) * MILKQUAN,
0),
YOGURT_SERV = (foodfreq(YOGURTONLYFREQ) * foodport(YOGURTONLYQUAN, ref=YOGURT_PORT_DF)) +
(foodfreq(BUTTERMILKFREQ) * foodport(BUTTERMILKQUAN, ref=BUTTERMILK_PORT_DF)),
LOWF_ICECREAMFROYO_SERV = ifelse(ICECREAMFROYOTYPE == 2,
foodfreq(ICECREAMFROYOFREQ) * foodport(ICECREAMFROYOQUAN)*2,
0),
LOWF_CHEESE_SERV = ifelse(CHEESETYPE == 1,
foodfreq(CHEESEFREQ) * CHEESEQUAN,
0),
LOWFATDAIRY_SERV = LOWF_MILK_SERV+YOGURT_SERV+LOWF_ICECREAMFROYO_SERV+LOWF_CHEESE_SERV,
WGRAIN_SERV = G_WHL,
ALLMEAT_SERV = M_MPF,
REDPROC_MEAT_SERV = (M_FRANK /1.5) + (M_MEAT/4),
FATOIL_SERV = (DFAT_OIL+DFAT_SOL)/14,
ADDEDSUGAR_SERV = ((ADD_SUG*4*4) / DT_KCAL)*100,
SODIUM_SERV = DT_SODI
)
} else{
print("Sorry, your input type is not currently supported. Current supported types include: BLOCK")
}
}
#' MED_SERV Calculation
#'
#' Calculate the serving sizes needed for calculating the MED dietary index per 1 day
#' @param RAW_DATA The raw data file that includes results and raw data of the dietary assessment
#' @param TYPE The type of dietary assessment you use. Current supported dietary assessment(s): BLOCK.
#' @return The serving sizes for the MED index/score
#' @examples
#' MED_SERV(RAW_DATA, TYPE="BLOCK")
#' @export
MED_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Standard food frequency and portion size response code
STD_FOOD_FREQ = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
STD_FREQ_SERV = c(0, 1/90, 1/30, 2.5/30, 1/7, 2/7, 3.5/7, 5.5/7, 1)
STD_FOOD_PORT = c(1, 2, 3, 4)
STD_PORT_SERV = c(0.25, 0.5, 1, 2)
STD_LUNCHMEAT_PORT_SERV = c(1, 2, 3, 4)
STD_HOTDOG_PORT_SERV = c(1, 2, 3)
STD_FOOD_FREQ_DF = data.frame(STD_FOOD_FREQ, STD_FREQ_SERV)
STD_FOOD_PORT_DF= data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Functions to match actual food frequency and portion to the standards
foodfreq = function(actual, ref=STD_FOOD_FREQ_DF){
ref[match(actual, ref[,1]),2]
}
foodport = function(actual, ref=STD_FOOD_PORT_DF){
ref[match(actual, ref[,1]),2]
}
#Match participant response food frequency to the standard food frequency response code
RAW_DATA %>%
mutate(
F_BERRIES = foodfreq(STRAWBERRIESFREQ)*foodport(STRAWBERRIESQUAN),
F_WHOLE = F_SOLID - F_BERRIES + F_BERRIES*2,
FRT_FRTJ_SERV = F_WHOLE + JUICE100,
VEG_SERV = V_DPYEL + 0.5*V_DRKGR + V_OTHER + V_STARCY + V_TOMATO,
WGRAIN_SERV = G_WHL,
LEGUMES_SERV = (LEGUMES*4) + M_SOY,
NUTS_SERV = M_NUTSD,
FISH_SERV = (M_FISH_HI+M_FISH_LO)/4,
REDPROC_MEAT_SERV = (M_FRANK/1.5) + (M_MEAT/4),
MONSATFAT_SERV = DT_MFAT/DT_SFAT,
ALCOHOL_SERV=A_BEV
)
} else{
print("Sorry, your input type is not currently supported. Current supported types include: BLOCK")
}
}
MEDI_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Standard food frequency and portion size response code
STD_FOOD_FREQ = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
STD_FREQ_SERV = c(0, 1/90, 1/30, 2.5/30, 1/7, 2/7, 3.5/7, 5.5/7, 1)
STD_FOOD_PORT = c(1, 2, 3, 4)
STD_PORT_SERV = c(0.25, 0.5, 1, 2)
STD_LUNCHMEAT_PORT_SERV = c(1, 2, 3, 4)
STD_HOTDOG_PORT_SERV = c(1, 2, 3)
STD_FOOD_FREQ_DF = data.frame(STD_FOOD_FREQ, STD_FREQ_SERV)
STD_FOOD_PORT_DF= data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Functions to match actual food frequency and portion to the standards
foodfreq = function(actual, ref=STD_FOOD_FREQ_DF){
ref[match(actual, ref[,1]),2]
}
foodport = function(actual, ref=STD_FOOD_PORT_DF){
ref[match(actual, ref[,1]),2]
}
#Match participant response food frequency to the standard food frequency response code
RAW_DATA %>%
mutate(
F_BERRIES = foodfreq(STRAWBERRIESFREQ)*foodport(STRAWBERRIESQUAN),
F_WHOLE = F_SOLID - F_BERRIES + F_BERRIES*2,
FRT_FRTJ_SERV = F_WHOLE + JUICE100,
VEG_SERV = V_DPYEL + 0.5*V_DRKGR + V_OTHER + V_STARCY + V_TOMATO,
LEGUMES_SERV = (LEGUMES*4) + M_SOY,
WGRAIN_SERV = G_WHL,
FISH_SERV = (M_FISH_HI+M_FISH_LO)/4,
DAIRY_SERV = D_TOTAL,
REDPROC_MEAT_SERV = (M_FRANK/1.5) + (M_MEAT/4),
NUTS_SERV = M_NUTSD,
MONSATFAT_SERV = DT_MFAT/DT_SFAT,
ALCOHOL_SERV=A_BEV
)
} else{
print("Sorry, your input type is not currently supported. Current supported types include: BLOCK")
}
}
#' AHEIP_SERV Calculation
#'
#' Calculate the serving sizes needed for calculating the AHEIP dietary index per 1 day
#' @param RAW_DATA The raw data file that includes results and raw data of the dietary assessment
#' @param TYPE The type of dietary assessment you use. Current supported dietary assessment(s): BLOCK.
#' @return The serving sizes for the AHEIP index/score
#' @examples
#' AHEIP_SERV(RAW_DATA, TYPE="BLOCK")
#' @export
AHEIP_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Standard food frequency and portion size response code
STD_FOOD_FREQ = c(1, 2, 3, 4, 5, 6, 7, 8, 9)
STD_FREQ_SERV = c(0, 1/90, 1/30, 2.5/30, 1/7, 2/7, 3.5/7, 5.5/7, 1)
STD_FOOD_PORT = c(1, 2, 3, 4)
STD_PORT_SERV = c(0.25, 0.5, 1, 2)
STD_LUNCHMEAT_PORT_SERV = c(1, 2, 3, 4)
STD_HOTDOG_PORT_SERV = c(1, 2, 3)
STD_FOOD_FREQ_DF = data.frame(STD_FOOD_FREQ, STD_FREQ_SERV)
STD_FOOD_PORT_DF= data.frame(STD_FOOD_PORT, STD_PORT_SERV)
#Functions to match actual food frequency and portion to the standards
foodfreq = function(actual, ref=STD_FOOD_FREQ_DF){
ref[match(actual, ref[,1]),2]
}
foodport = function(actual, ref=STD_FOOD_PORT_DF){
ref[match(actual, ref[,1]),2]
}
#Match participant response food frequency to the standard food frequency response code
RAW_DATA %>%
mutate(
F_BERRIES = foodfreq(STRAWBERRIESFREQ)*foodport(STRAWBERRIESQUAN),
F_WHOLE = F_SOLID - F_BERRIES + F_BERRIES*2,
VEG_SERV = V_DPYEL + 0.5*V_DRKGR + V_OTHER + V_STARCY + V_TOMATO,
FRT_SERV = F_WHOLE,
WHITERED_RT_SERV = ((M_POULT+M_FISH_HI+M_FISH_LO)/4) /  ((M_FRANK /1.5) + (M_MEAT/4)),
FIBER_SERV = DT_FIBE,
TRANS_SERV = ((DT_TRFAT * 9) / DT_KCAL)*100,
POLYSAT_RT = DT_PFAT / DT_SFAT,
CALCIUM_SERV = DT_CALC,
FOLATE_SERV = DT_FOLFD,
IRON_SERV = DT_IRON
)
} else{
print("Sorry, your input type is not currently supported. Current supported types include: BLOCK")
}
}
#' HEI2015_SERV Calculation
#'
#' Calculate the serving sizes needed for calculating the HEI2015 dietary index per 1 day. For NHANES_FPED, please first use NHANES_FPED_PRE_HEI15 to preprocess your data.
#' @param RAW_DATA The raw data file that includes results and raw data of the dietary assessment
#' @param TYPE The type of dietary assessment you use. Current supported dietary assessment(s): BLOCK, AARP, NHANES_FPED.
#' @return The serving sizes for the HEI2015 index/score
#' @examples
#' HEI2015_SERV(RAW_DATA, TYPE="BLOCK"), HEI2015_SERV(RAW_DATA, TYPE="AARP"), HEI2015_SERV(RAW_DATA, TYPE="NHANES_FPED")
#' @export
HEI2015_SERV = function(RAW_DATA, TYPE){
if (TYPE == "BLOCK"){
#Match participant response food frequency to the standard food frequency response code
RAW_DATA %>%
mutate(
TOTALFRT_SERV = F_TOTAL/(DT_KCAL/1000),
FRT_SERV = F_SOLID/(DT_KCAL/1000),
VEG_SERV = (V_TOTAL+LEGUMES)/(DT_KCAL/1000),
GREEN_N_BEAN_SERV = (V_DRKGR+LEGUMES)/(DT_KCAL/1000),
TOTALPRO_SERV = (M_MPF+M_EGG+M_NUTSD+M_SOY+(LEGUMES*4))/(DT_KCAL/1000),
SEAPLANTPRO_SERV = (M_FISH_HI+M_FISH_LO+M_SOY+M_NUTSD+(LEGUMES*4))/(DT_KCAL/1000),
WHOLEGRAIN_SERV = G_WHL/(DT_KCAL/1000),
DAIRY_SERV = D_TOTAL/(DT_KCAL/1000),
FATTYACID_SERV = ifelse(DT_SFAT == 0, 0, (DT_MFAT + DT_PFAT)/DT_SFAT),
REFINEDGRAIN_SERV = G_NWHL/(DT_KCAL/1000),
SODIUM_SERV = (DT_SODI/1000)/(DT_KCAL/1000),
ADDEDSUGAR_SERV = ((ADD_SUG*4*4) / DT_KCAL)*100,
SATFAT_SERV = ((DT_SFAT*9)/DT_KCAL)*100,
TOTALKCAL = DT_KCAL
)
} else if(TYPE == "AARP"){
#Match participant response food frequency to the standard food frequency response code
RAW_DATA %>%
mutate(
mped_M_SOY=0,
TOTALFRT_SERV = mped_f_total/(calories/1000),
FRT_SERV = mped_f_nojuice/(calories/1000),
VEG_SERV = (mped_v_total+mped_legumes)/(calories/1000),
GREENNBEAN_SERV = (mped_v_drkgr+mped_legumes)/(calories/1000),
TOTALPRO_SERV = (mped_M_MPF+mped_M_EGG+mped_M_NUTSD+mped_M_SOY+(mped_legumes*4))/(calories/1000),
SEAPLANTPRO_SERV = (mped_M_FISH_HI+mped_M_FISH_LO+mped_M_SOY+(mped_legumes*4))/(calories/1000),
WHOLEGRAIN_SERV = mped_g_whl/(calories/1000),
DAIRY_SERV = mped_d_total/(calories/1000),
FATTYACID_SERV = ifelse(fatsaturated == 0, 0, (fatmono+fatpoly)/fatsaturated),
REFINEDGRAIN_SERV = mped_G_NWHL/(calories/1000),
SODIUM_SERV = (SODIUM/1000)/(calories/1000),
ADDEDSUGAR_SERV = ((mped_add_sug*4*4) / calories)*100,
SATFAT_SERV = ((fatsaturated*9)/calories)*100,
TOTALKCAL = calories
)
} else if(TYPE == "NHANES_FPED"){
#Match participant response food frequency to the standard food frequency response code
RAW_DATA %>%
mutate(
TOTALFRT_SERV = DR1T_F_TOTAL/(DR1TKCAL/1000),
FRT_SERV = (DR1T_F_CITMLB+DR1T_F_OTHER)/(DR1TKCAL/1000),
VEG_SERV = (DR1T_V_TOTAL+DR1T_V_LEGUMES)/(DR1TKCAL/1000),
GREENNBEAN_SERV = (DR1T_V_DRKGR+DR1T_V_LEGUMES)/(DR1TKCAL/1000),
TOTALPRO_SERV = (DR1T_PF_MPS_TOTAL+DR1T_PF_EGGS+DR1T_PF_NUTSDS+DR1T_PF_SOY+DR1T_PF_LEGUMES)/(DR1TKCAL/1000),
SEAPLANTPRO_SERV = (DR1T_PF_SEAFD_HI+DR1T_PF_SEAFD_LOW+DR1T_PF_NUTSDS+DR1T_PF_SOY+DR1T_PF_LEGUMES)/(DR1TKCAL/1000),
WHOLEGRAIN_SERV = DR1T_G_WHOLE/(DR1TKCAL/1000),
DAIRY_SERV = DR1T_D_TOTAL/(DR1TKCAL/1000),
FATTYACID_SERV = ifelse(DR1TSFAT == 0, 0, (DR1TMFAT+DR1TPFAT)/DR1TSFAT),
REFINEDGRAIN_SERV = DR1T_G_REFINED/(DR1TKCAL/1000),
SODIUM_SERV = (DR1TSODI/1000)/(DR1TKCAL/1000),
ADDEDSUGAR_SERV = ((DR1T_ADD_SUGARS*4*4) / DR1TKCAL)*100,
SATFAT_SERV = ((DR1TSFAT*9)/DR1TKCAL)*100,
TOTALKCAL = DR1TKCAL
)
} else{
print("Sorry, your input FFQ type is not currently supported. Current supported FFQs include: BLOCK, AARP, NHANES_FPED")
}
}
#' NHANES_FPED_PRE_HEI15
#'
#' Prepare the NHANES_FPED data (after 2005) for calculating the serving sizes for HEI2015.
#' @param FPED_PATH The file path for the FPED data. The file name should be like: FPED.fped_dr1tot_1112.
#' @param NUTRIENT_PATH The file path for the NUTRIENT data. The file name should be like: NH.DR1TOT_G.
#' @param DEMO_PATH The file path for the DEMOGRAPHIC data. The file name should be like: NH.DEMO_G.
#' @return The cleaned data ready for calculating the serving sizes for HEI2015.
#' @examples
#' FPED_PATH = "/Users/james/Desktop/data/FPED.fped_dr1tot_1112.csv"
#' NUTRIENT_PATH = "/Users/james/Desktop/data/NH.DR1TOT_G"
#' DEMO_PATH = "/Users/james/Desktop/data/NH.DEMO_G"
#' NHANES_FPED_PRE_HEI15 (FPED_PATH, NUTRIENT_PATH, DEMO_PATH)
#' @export
NHANES_FPED_PRE_HEI15 = function(FPED_PATH, NUTRIENT_PATH, DEMO_PATH){
FPED = read.csv(FPED_PATH)
NUTRIENT = read.csv(NUTRIENT_PATH)
DEMO = read.csv(DEMO_PATH)
NUTRIENT = NUTRIENT %>%
filter(DR1DRSTZ == 1) %>%
select(SEQN, WTDRD1, DR1TKCAL, DR1TSFAT, DR1TALCO, DR1TSODI, DR1DRSTZ, DR1TMFAT, DR1TPFAT) %>%
arrange(SEQN)
DEMO = DEMO %>%
filter(RIDAGEYR >= 2) %>%
select(SEQN, RIDAGEYR, RIAGENDR, SDDSRVYR, SDMVPSU, SDMVSTRA) %>%
arrange(SEQN)
FPED = FPED %>%
arrange(SEQN)
COHORT = NUTRIENT %>%
inner_join(DEMO, by = c("SEQN" = "SEQN")) %>%
left_join(FPED, by = c("SEQN" = "SEQN"))
return(COHORT)
}
# devtools::install_github("jamesjiadazhan/dietaryindex")
# library(dietaryindex)
DATA_PATH = "/Users/yan/Desktop/Emory University - Ph.D./Research rotation/Microbiome research/Data/Dietary data/data-2022-05-03-16-48-28-rand-1807/data-2022-05-03-16-48-28-raw-data-and-results.csv"
RAW_DATA = read.csv(DATA_PATH)
# DATA_PATH <- "/Users/james/Desktop/data.csv"
# RAW_DATA <- read_csv(DATA_PATH)
AHEI_DATA = AHEI_SERV(RAW_DATA, TYPE="BLOCK")
AHEI_DATA2 = AHEI(AHEI_DATA,
VEG_SERV,
FRT_SERV,
WGRAIN_SERV,
NUTSLEG_SERV,
N3FAT_SERV,
PUFA_SERV,
SSB_FRTJ_SERV,
REDPROC_MEAT_SERV,
TRANS_SERV,
SODIUM_SERV,
ALCOHOL_SERV)
install.packages("dplyr")
AHEI_DATA2
